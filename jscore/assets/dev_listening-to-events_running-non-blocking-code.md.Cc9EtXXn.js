import{_ as i,c as a,o as n,ae as e}from"./chunks/framework.CqV5Rifv.js";const E=JSON.parse('{"title":"Running Non-blocking Code","description":"","frontmatter":{},"headers":[],"relativePath":"dev/listening-to-events/running-non-blocking-code.md","filePath":"dev/listening-to-events/running-non-blocking-code.md"}'),t={name:"dev/listening-to-events/running-non-blocking-code.md"};function l(h,s,p,k,o,r){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="running-non-blocking-code" tabindex="-1">Running Non-blocking Code <a class="header-anchor" href="#running-non-blocking-code" aria-label="Permalink to &quot;Running Non-blocking Code&quot;">​</a></h1><p>JSCore runs JavaScript in a blocking manner - the entire game will wait for your JavaScript code to finish running before rendering the next frame. So a web request that takes 5 seconds will freeze your game for 5 seconds.</p><p>In this case, you can run the code in a new thread without blocking the game.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWebRequestRunnable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// And it too can take arguments.</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myWebRequestRunnable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;argument 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;argument 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="maintaining-execution-order" tabindex="-1">Maintaining Execution Order <a class="header-anchor" href="#maintaining-execution-order" aria-label="Permalink to &quot;Maintaining Execution Order&quot;">​</a></h2><p>If you spawn a runnable in a new thread, there is no guarantee in the order of execution.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myRunnable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// this prints out &#39;hi&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;and then this&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>It is possible that <em>&#39;hi&#39;</em> gets printed before <em>&#39;and then this&#39;</em>, but it is also possible that <em>&#39;and then this&#39;</em> comes before <em>&#39;hi&#39;</em>.</p><p>You can maintain order by using <strong>JavaScript Callbacks</strong>, for example.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">thisRunnablePrintsHiAndThen.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;and then this&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><blockquote><p>JSCore does not support <code>setTimeout</code> due to runtime restriction.</p></blockquote><h2 id="preventing-callback-hell" tabindex="-1">Preventing Callback Hell <a class="header-anchor" href="#preventing-callback-hell" aria-label="Permalink to &quot;Preventing Callback Hell&quot;">​</a></h2><p>Callback hell is when there are multiple levels of callback functions, this is particularly a problem in JSCore as each time <code>.spawn()</code> is called, a new thread is spawned to run the code, which is a slow and expensive task.</p><p>Take this runnable callback hell for example.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ... some code before</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">runnableAndThen.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  anotherRunnableAndThen.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    anotherAnotherRunnableAndThen.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Reached the end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// some code after ...</span></span></code></pre></div><p>We used <code>runnableAndThen.spawn( ... )</code> because we don&#39;t want to block execution of the main press, this code is suboptimal because by the time we reach <code>console.log</code>, we have created 3 threads, and spawning new threads is slow.</p><p>To avoid this, <code>.spawn()</code> should be used <strong>only when absolutely necessary</strong>. In this case, the code can be refactored to use only a singular callback, maintain the execution of the functions, and not blocking the main thread.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ... some code before</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">runnableAndThen.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">spawn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  anotherRunnable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">runF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  anotherAnotherRunnable.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">runF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Reached the end&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// some code after ...</span></span></code></pre></div>`,18)]))}const c=i(t,[["render",l]]);export{E as __pageData,c as default};
